#include <iostream>
#include <list>
#include <ctime>
#include "GameManager.h"
#include "UserInterface.h"
#include "Character.h"
#include "GameState.h"
#include "MenuGameState.h"
#include "BattleGameState.h"
#include "ExitGameState.h"
#include "MainMenuUserInterface.h"
#include "InputOptionsUserInterface.h"
#include "TextDisplayUserInterface.h"
#include <Windows.h>

#define MIN_TIME_STEP 0.08

GameManager::GameManager(std::list<Character*> characters, InputReader* inputReader)
	: characters(characters), currentState(nullptr)
{
	inputOptionsUserInterface = new InputOptionsUserInterface();
	optionSelector = new OptionSelector(inputReader, inputOptionsUserInterface);

	optionSelector->getOnQueryCompletedEvent().addListener(this);

	// STATE INITIALIZATION

	exitState = new ExitGameState();

	// TODO: Implement some way of selecting the game characters to go into the battle
	Character* enemy = characters.front();

	// Get an iterator pointing to the second element
	std::list<Character*>::iterator startOfParty = characters.begin();
	startOfParty++;

	std::vector<Character*> party(startOfParty, characters.end());

	battleState = new BattleGameState(party, enemy, optionSelector);

	hubState = new MenuGameState(std::vector<std::pair<GameState*, std::string>>{{battleState, "Battle"}, {exitState, "Quit"}}, optionSelector);

	// Initialize the user interfaces
	userInterfaces =
	{
		{hubState, std::list<UserInterface*> {new MainMenuUserInterface("DUNGEON RUNNER")}},
		{battleState, std::list<UserInterface*> {new TextDisplayUserInterface(dynamic_cast<BattleGameState*>(battleState)->getCurrentBattleTextChangedEvent())}},
		{exitState, std::list<UserInterface*>()}
	};

	// Initialize start state
	currentState = hubState;
}

GameManager::~GameManager()
{
	// Even though GameManager owns this instance and will delete it anyways,
	// this is here for completeness
	optionSelector->getOnQueryCompletedEvent().removeListener(this);
	
	// Free state instances and their UIs
	for (const auto& pair : userInterfaces)
	{
		// Based on the assumption that no user interface instance appears twice
		// (which might result in memory being freed twice)
		for (UserInterface* userInterface : pair.second)
		{
			delete userInterface;
		}

		// State should only be freed after user interfaces since they depend
		// on the states still being allocated
		delete pair.first;
	}

	delete inputOptionsUserInterface;

	delete optionSelector;

}


void clear_screen(char fill = ' ');

void GameManager::start()
{
	std::cout << "Game start!" << std::endl;

	// Run initial frame of UI
	for (UserInterface* ui : userInterfaces[currentState])
		std::cout << ui->getDisplay() << std::endl;

	// GOAL 1: Create a basic vertical slice where
	// the UI displays the health bar of the first
	// character in the list, and the battle system
	// asks the user every frame how much damage to
	// deal to the character. Once the character has
	// died, the battle system should terminate and
	// inform the game that the battle has concluded,
	// ultimately causing the game to terminate
	
	clock_t timeOfLastFrame = clock();

	// Keep looping while there are still processes being run
	while (currentState != exitState)
	{
		// Update delta time for this frame
		float deltaTime = float(clock() - timeOfLastFrame) / CLOCKS_PER_SEC;

		// Define a min time step so that window has time to refresh
		if (deltaTime < MIN_TIME_STEP)
			continue;

		timeOfLastFrame = clock();

		// Apply update for current frame
			
		// Display visuals for each process
		clear_screen();

		// UI must be displayed first since UI generated by
		// input request performed during main tick update
		// in a game state must be displayed after all other UI
		for (UserInterface* ui : userInterfaces[currentState])
			std::cout << ui->getDisplay() << std::endl;

		// Run the update for each process
		currentState->tick(deltaTime);

		// Fix the deltaTime after input request
		if (inputEventRaisedThisFrame)
		{
			inputEventRaisedThisFrame = false;

			// Reset clock since input resolution may take multiple seconds and throw off deltaTime for next frame
			timeOfLastFrame = clock();
		}

		// Check for transitions
		// DESIGN CHOICE: Hard-code all states to transition back to the hub state once they
		// have finished (the only transition condition) and the hub state to transition to
		// the state selcted by the user instead of using an explicit transition table.
		// Due to the simplicity of the game structure, the overhead of a full-blown
		// state machine with state transition tables was not worth it.
		if (currentState->isFinished())
		{
			GameState* nextState = currentState == hubState ? hubState->getSelectedState() : hubState;

			currentState->onExit();
			currentState = nextState;
			currentState->onEnter();
		}
	}
	
}

//void GameManager::cleanUpActiveProcess()
//{
//	if (activeUserInterfaces != nullptr)
//	{
//		for (UserInterface* ui : *activeUserInterfaces)
//			delete ui;
//
//		delete activeUserInterfaces;
//	}
//	
//	if(currentState != nullptr)
//		delete currentState;
//
//	activeUserInterfaces = nullptr;
//	currentState = nullptr;
//}

void GameManager::onNotify(bool eventData)
{
	inputEventRaisedThisFrame = true;
}


#if defined(_WIN32)
#define PLATFORM_NAME "windows" // Windows
#elif defined(_WIN64)
#define PLATFORM_NAME "windows" // Windows
#endif
void clear_screen(char fill) {
	if (PLATFORM_NAME == "windows")
	{
		// This is a little function from:
		// https://stackoverflow.com/questions/5866529/how-do-we-clear-the-console-in-assembly/5866648#5866648

		COORD tl = { 0,0 };
		CONSOLE_SCREEN_BUFFER_INFO s;
		HANDLE console = GetStdHandle(STD_OUTPUT_HANDLE);
		GetConsoleScreenBufferInfo(console, &s);
		DWORD written, cells = s.dwSize.X * s.dwSize.Y;
		FillConsoleOutputCharacter(console, fill, cells, tl, &written);
		FillConsoleOutputAttribute(console, s.wAttributes, cells, tl, &written);
		SetConsoleCursorPosition(console, tl);
	}
}

